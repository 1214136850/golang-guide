# 一面
[百度在线一面-2024-7-10.mp3](https://www.yuque.com/attachments/yuque/0/2024/mp3/22219483/1720615511671-d55c4b49-2b6c-43a3-8e15-f0281d942226.mp3?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2024%2Fmp3%2F22219483%2F1720615511671-d55c4b49-2b6c-43a3-8e15-f0281d942226.mp3%22%2C%22name%22%3A%22%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E4%B8%80%E9%9D%A2-2024-7-10.mp3%22%2C%22size%22%3A112199974%2C%22ext%22%3A%22mp3%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u086e017d-3e58-4f56-9a05-dbe2ea4fef1%22%2C%22taskType%22%3A%22transfer%22%2C%22type%22%3A%22audio%2Fmpeg%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u4f874408%22%2C%22card%22%3A%22file%22%7D)

1. 自我介绍
2. 挑一个比较熟悉比较好的项目讲一讲
3. 难解决的问题是什么？
4.  mysql
   1. 底层数据结构
   2. innodb
   3. 最左匹配原则，为什么会有这种现象发生呢
   4. 那如果联合索引用order by排序，也要遵循最左匹配原则吗，用联合索引的最后一列去order by，他会走索引吗，讲一下都order by和只order  by后一列的情况
      - **完整 ORDER BY 排序**：如果 `ORDER BY` 子句涵盖了联合索引的所有列，并且没有其他限制条件，数据库通常会选择使用索引的有序性来优化查询。
      - **只 ORDER BY 最后一列**：如果 `ORDER BY` 只涉及到了索引的最后一列，并且没有其他索引列用于过滤或限制数据，数据库可能会选择全表扫描而不是使用索引，以获得更高的查询性能。
5. 代码考核
   1.  给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
说明：

为什么返回数值是整数，但输出的答案是数组呢？

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
print(nums[i]);
}

示例 1：

输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。

示例 2：

输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。

提示：

1 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums 已按升序排列
   2. 两数之和
      1. 有一个限定条件，输入的数组特别长，以文件的形式存储的，每个数组以逗号隔开，存的是txt在磁盘上，需要一个t的存储空间，是没法直接加载到内存的。这样的情况下怎么办，说一下思路
         1. 分块处理，怎么分，按什么规则分，读到之后该怎么做 
         2. 1个t的文件做拆分，拆成1个g一个文件，第一个文件拿出来，拿第一文件的第一个数字，在这个文件本身当中找有没有符合需求的目标数字，没有的话就加载第二个，以此内推。然后拿出第一个文件的第二个数，继续一次内推遍历，直到所有的数都遍历一次。这的复杂度会非常高，有没有好的办法优化？
            1. 答案：切块的时候按照一定的规则去切，比如找到了一个数值，有一个target就能知道要找到的对应的那个数。那么在对文件切块的时候按照一定的规则去切，比如分1万份，把所有的数字对一万取模，是不是一部分特征的数组都会放到同一个文件里，那么要找的值也对1万取模就能直接找到他应该在哪个文件里，然后直接去加载那个文件，看他有没有这个数值，这样一个数值就比较完了，就不用遍历所有的数。
            2. 答案2：也可以直接构建一个大的数据结构，对磁盘所有的文件里面进行排序，也可以解决问题。
6. 反问

![](https://cdn.nlark.com/yuque/0/2024/png/22219483/1720772016604-b340a816-4743-45e6-a35b-a4a61d383a30.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_750%2Climit_0#averageHue=%231d1d20&from=url&id=hYE5p&originHeight=478&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
